# Licencia MIT
# Copyright (c) 2025 Jorge Men√©ndez S.
# Por la presente se concede permiso, sin cargo, a cualquier persona que obtenga una copia de este software y los archivos de documentaci√≥n asociados (el "Software"), para tratar el Software sin restricci√≥n, incluidos, entre otros, los derechos de usar, copiar, modificar, fusionar, publicar, distribuir, sublicenciar y/o vender copias del Software, y para permitir a las personas a quienes se les proporcione el Software que lo hagan, sujeto a las siguientes condiciones:
# El aviso de copyright anterior y este aviso de permiso se incluir√°n en todas las copias o partes sustanciales del Software.
# EL SOFTWARE SE PROPORCIONA "TAL CUAL", SIN GARANT√çA DE NING√öN TIPO, EXPRESA O IMPL√çCITA, INCLUYENDO PERO NO LIMITADA A LAS GARANT√çAS DE COMERCIABILIDAD, IDONEIDAD PARA UN PROP√ìSITO PARTICULAR Y NO INFRACCI√ìN. EN NING√öN CASO LOS AUTORES O TITULARES DEL COPYRIGHT SER√ÅN RESPONSABLES POR NINGUNA RECLAMACI√ìN, DA√ëO U OTRA RESPONSABILIDAD, YA SEA EN UNA ACCI√ìN DE CONTRATO, AGRAVIO O DE OTRO MODO, DERIVADA DE, O EN CONEXI√ìN CON EL SOFTWARE O EL USO U OTRO TIPO DE ACCIONES EN EL SOFTWARE.

import re
import os
import sys
from datetime import datetime, timedelta

# Diccionario de abreviaturas m√©dicas
ABREVIATURAS = {
    "HTA": "Hipertensi√≥n arterial", "DM2": "Diabetes Mellitus tipo 2",
    "IVU": "Infecci√≥n de v√≠as urinarias", "EPOC": "Enfermedad pulmonar obstructiva cr√≥nica",
    "ERC HD": "Enfermedad renal cr√≥nica en hemodi√°lisis", "ERC": "Enfermedad renal cr√≥nica",
    "ERA": "Enfermedad renal aguda", "IRA": "Insuficiencia respiratoria aguda",
    "ICC": "Insuficiencia cardiaca congestiva", "SCA": "S√≠ndrome coronario agudo",
    "IAM": "Infarto agudo de miocardio", "ACV": "Accidente cerebrovascular",
    "ECV": "Enfermedad cerebrovascular", "AIT": "Accidente isqu√©mico transitorio",
    "TB": "Tuberculosis", "NAC": "Neumon√≠a adquirida en la comunidad",
    "NIH": "Neumon√≠a intrahospitalaria", "DP": "Derrame pleural",
    "VIH": "Virus de la inmunodeficiencia humana", "HDA": "Hemorragia digestiva alta",
    "HDB": "Hemorragia digestiva baja", "HD": "Hemodi√°lisis",
    "FAV": "F√≠stula arteriovenosa", "PA": "Pancreatitis aguda",
    "EMB": "Embarazo", "SG": "Semanas de gestaci√≥n", "HIPERK": "Hiperkalemia",
    "HIPERNA": "Hipernatremia", "HIPOK": "Hipokalemia", "HIPONA": "Hiponatremia",
    "DNPC": "Desnutrici√≥n", "PPL": "Persona privada de la libertad",
    "HPB": "Hiperplasia prost√°tica benigna"
}

# Configuraci√≥n de ubicaciones
LUGARES = {"h": "HIDRATACI√ìN", "hidrat": "HIDRATACI√ìN", "hid": "HIDRATACI√ìN",
           "o": "OBSERVACI√ìN", "obs": "OBSERVACI√ìN", "vc": "VIGILANCIA CR√çTICA"}

def limpiar_pantalla():
    """Limpia la pantalla de la terminal"""
    os.system('cls' if os.name == 'nt' else 'clear')

def expandir_abreviaturas(texto):
    """Reemplaza abreviaturas m√©dicas por su significado completo"""
    for abrev in sorted(ABREVIATURAS.keys(), key=len, reverse=True):
        patron = r'\b' + re.escape(abrev) + r'\b'
        texto = re.sub(patron, ABREVIATURAS[abrev], texto, flags=re.IGNORECASE)
    return texto

def obtener_fecha_turno():
    """Determina fecha y turno actual"""
    ahora = datetime.now()
    if 18 <= ahora.hour <= 21:
        return ahora.strftime("%d/%m/%Y"), "AM"
    elif 6 <= ahora.hour <= 9:
        return (ahora - timedelta(days=1)).strftime("%d/%m/%Y"), "PM"
    return ahora.strftime("%d/%m/%Y"), "AM"

def formatear_nombre(nombre):
    """Formatea nombre como 'APELLIDOS, NOMBRE'"""
    partes = nombre.strip().split()
    if len(partes) >= 2:
        return f"{' '.join(partes[:-1]).upper()}, {partes[-1].upper()}"
    return nombre.upper()

def traducir_lugar(lugar):
    """Traduce c√≥digo de ubicaci√≥n a texto completo"""
    return LUGARES.get(lugar.lower().strip(), lugar.upper())

def procesar_linea_paciente(linea, tipo):
    """Procesa una l√≠nea de paciente seg√∫n el tipo (coordinado/pendiente)"""
    if tipo == "coordinado":
        match = re.match(r"(.+?)\s*(?:\.{2,}|Dx|\s-\s)\s*(.+?)\.\s*(\w+)\s*(\d+)", linea, re.IGNORECASE)
        if match:
            nombre, dx, lugar, cama = match.groups()
            dx_limpio = re.sub(r'^\s*Dx\s*', '', dx.strip(), flags=re.IGNORECASE)
            return (formatear_nombre(nombre), 
                    expandir_abreviaturas(dx_limpio),
                    f"‚Üí üõèÔ∏è *{traducir_lugar(lugar)}, CAMA {cama.upper()}*")
    
    elif tipo == "pendiente":
        match = re.match(r"(.+?)\s*(?:\.{2,}|Dx|\s-\s)\s*(.+?)\.\s*(cn|sn)(.*)", linea, re.IGNORECASE)
        if match:
            nombre, dx, nota, comentario = match.groups()
            dx_limpio = re.sub(r'^\s*Dx\s*', '', dx.strip(), flags=re.IGNORECASE)
            nota_fmt = "‚úÖ Con nota" if nota.lower() == "cn" else "‚ùå Sin nota"
            
            comentario_fmt = ""
            if comentario.strip():
                comentario_limpio = comentario.strip(" .")
                comentario_expandido = expandir_abreviaturas(comentario_limpio)
                comentario_fmt = f"\nüí¨ {comentario_expandido[0].upper()}{comentario_expandido[1:]}"
                if not comentario_fmt.endswith('.'):
                    comentario_fmt += '.'
            
            return (formatear_nombre(nombre), 
                    expandir_abreviaturas(dx_limpio),
                    nota_fmt + comentario_fmt)
    
    return None

def procesar_coordinados(texto):
    """Procesa bloque de pacientes coordinados"""
    resultados = []
    for linea in [l.strip() for l in texto.split("\n") if l.strip()]:
        if datos := procesar_linea_paciente(linea, "coordinado"):
            nombre, dx, ubicacion = datos
            resultados.append(f"{nombre}\n_Diagn√≥stico: {dx}_\n{ubicacion}")
    return resultados

def procesar_pendientes(texto):
    """Procesa bloque de pacientes pendientes ordenados por fecha"""
    fechas_pacientes = []
    fecha_actual, pacientes_actual = None, []
    
    for linea in [l.strip() for l in texto.split("\n") if l.strip()]:
        if re.match(r"\d{1,2}/\d{1,2}", linea):
            if fecha_actual and pacientes_actual:
                fechas_pacientes.append((fecha_actual, pacientes_actual))
            fecha_actual, pacientes_actual = linea, []
        elif fecha_actual:
            pacientes_actual.append(linea)
    
    if fecha_actual and pacientes_actual:
        fechas_pacientes.append((fecha_actual, pacientes_actual))
    
    # Ordenar por fecha
    fechas_ordenadas = []
    for fecha, pacientes in fechas_pacientes:
        try:
            dia, mes = map(int, fecha.split('/')[:2])
            a√±o = datetime.now().year - (1 if mes > datetime.now().month else 0)
            fechas_ordenadas.append((datetime(a√±o, mes, dia), pacientes))
        except (ValueError, IndexError):
            continue
    
    fechas_ordenadas.sort()
    
    # Formatear salida
    salida = []
    for fecha_dt, pacientes in fechas_ordenadas:
        salida.append(f"*{fecha_dt.strftime('%d/%m/%Y')}*")
        for idx, linea_pac in enumerate(pacientes, 1):
            if datos := procesar_linea_paciente(linea_pac, "pendiente"):
                nombre, dx, info = datos
                salida.append(f"{idx}. {nombre}\n_Diagn√≥stico: {dx}_\n{info}")
        salida.append("")
    
    return salida

def generar_reporte(texto_raw):
    """Genera el reporte completo formateado para WhatsApp"""
    fecha, turno = obtener_fecha_turno()
    encabezado = f"üè• *GUARDIA {fecha} {turno}*"
    
    # Separar secciones
    if "Pendientes" in texto_raw:
        partes = texto_raw.split("Pendientes")
        coord_texto = partes[0].replace("Coordinados", "").strip()
        pend_texto = partes[1].strip()
    else:
        coord_texto = texto_raw.replace("Coordinados", "").strip()
        pend_texto = ""
    
    # Construir reporte
    lineas = [encabezado, ""]
    
    if coord_texto:
        lineas.extend(["üìù *INGRESOS COORDINADOS*", ""])
        coordinados = procesar_coordinados(coord_texto)
        for i, coord in enumerate(coordinados, 1):
            lineas.append(f"{i}. {coord}")
            lineas.append("")
    
    if pend_texto:
        lineas.extend(["‚öïÔ∏è *INGRESOS PENDIENTES DE MEDICINA INTERNA*", ""])
        lineas.extend(procesar_pendientes(pend_texto))
    
    return "\n".join(lineas)

def leer_entrada_usuario():
    """
    Lee m√∫ltiples l√≠neas de entrada hasta que el usuario presiona Ctrl+D/Ctrl+Z
    """
    print("Pega el texto plano. Finaliza con Ctrl+D (Linux/Mac) o Ctrl+Z (Windows) y Enter:")
    print()
    
    lineas = []
    try:
        while True:
            linea = input()
            lineas.append(linea)
    except EOFError:
        # Ctrl+D o Ctrl+Z presionado
        pass
    
    return "\n".join(lineas)

def main():
    """Funci√≥n principal"""
    limpiar_pantalla()
    print("üìã Formateador de Reporte M√©dico para WhatsApp")
    print("=" * 50)
    
    try:
        # Leer entrada del usuario
        texto_raw = leer_entrada_usuario()
        
        if not texto_raw.strip():
            print("‚ùå No se ingres√≥ texto. El programa terminar√°.")
            return
        
        # Limpiar pantalla y mostrar resultado formateado
        limpiar_pantalla()
        reporte = generar_reporte(texto_raw)
        print(reporte)
        
    except KeyboardInterrupt:
        print("\n\n‚ùå Programa interrumpido por el usuario.")
    except Exception as e:
        print(f"\n‚ùå Error inesperado: {e}")

if __name__ == "__main__":
    main()
